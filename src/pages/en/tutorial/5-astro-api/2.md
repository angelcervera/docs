---
layout: ~/layouts/TutorialLayout.astro
title: Generating pages dynamically
setup: |
  import Checklist from '~/components/Checklist.astro';
  import Goals from '~/components/tutorial/Goals.astro';
  import MultipleChoice from '~/components/tutorial/MultipleChoice.astro';
  import Option from '~/components/tutorial/Option.astro';
---

<Goals>
  - generated multiple page routes dynamically from a single Astro component
  - used `[bracket]` notation to identify the dynamic route parameter
  - exported a `getStaticPaths()` function to specify exactly which paths will be pre-rendered
</Goals>

## Dynamic Page Routing

Just like you used `Astro.glob()` to generate a list of all blog posts, you can create entire sets of pages dynamically using `getStaticPaths()`. This function written in an Astro component script returns an array of page routes, and all of the pages at those routes will use the same component template.

To start, you will create a **static** page for an individual blog tag. And then, you will convert this `.astro` file that builds one single page into a file that creates multiple routes dynamically: one for every blog tag you use on the site.

### Create a static page placeholder

1. Create a new file at `src/pages/tags/` (you will make a new folder) with the filename `tag.astro` and add the following code:

    ```astro
    ---
    // src/pages/tags/tag.astro

    import BaseLayout from '../../layouts/BaseLayout.astro';
    let title = "tag"; 
    ---
    <BaseLayout title={title}>
      <p>Posts tagged with {title}</p>
    </BaseLayout>
    ```

2. Visit `localhost:3000/tags/tag` in your browser (or add `/tags/tag` to the end of your preview URL) and verify that you have a new page on your site.

## Create a Dynamic Page

1. Convert this static route (one file -> one page) to a dynamic route (one file -> many pages) by
    - **renaming the page to `[tag].astro`** (add brackets around the word "tag")
    - **exporting a `getStaticPaths()` function** in the component script.

    ```diff
    ---
    // src/pages/posts/tags/[tag].astro

    import BaseLayout from '../../layouts/BaseLayout.astro';

    + export async function getStaticPaths({ }) {
    +   return[
    +    {params: {tag: "astro"}},
    +    {params: {tag: "sucesses"}},
    +    {params: {tag: "community"}},
    +    {params: {tag: "learning in public"}}
    +   ]
    + }

    - let title = "tag"; 
    + const { tag } = Astro.params
    + let title = tag; 
    ---
    <BaseLayout title={title}>
      <p>Posts tagged with {title}</p>    
    </BaseLayout>
    ```

2. Visit `localhost:3000/tags/astro` in your browser preview and you should see a page, generated dynamically from `[tag].astro`. Check that you also have pages created at `/tags/successes`, `/tags/community`, and `/tags/learning%20in%20public`. 

    Each of these pages uses the same component template to create what you see on the page, which means they each have access to their parameter value of `tag` for that page, but nothing else... yet!

    In addition to defining a parameter for each route, let's give each page some props.

3. Add code to your `getStaticPaths()` function in order to make data from all your blog posts available to each page route.

    Be sure to give each route in your array the new props, and then make those props available to your component template outside of your function.

    ```diff
    // src/pages/posts/tags/[tag].astro

      export async function getStaticPaths({}){
    +  const allPosts = await Astro.glob('../posts/*.md');

      return [
        {params: {tag: "astro"}, props: {posts: allPosts}},
        {params: {tag: "sucesses"}, props: {posts: allPosts}},
        {params: {tag: "community"}, props: {posts: allPosts}},
        {params: {tag: "blogging"}, props: {posts: allPosts}},
        {params: {tag: "setbacks"}, props: {posts: allPosts}},
        {params: {tag: "learning in public"}, props: {posts: allPosts}}
      ]
    }

    + const { posts } = Astro.props
      const { tag } = Astro.params
    ```

## Analyze the pattern

For each of the following, state whether the code is written **inside** the `getStaticPath()` function, or **outside** of it, in your component script.

1. The `Astro.glob()` call to receive information about all your `.md` files to pass to each page route.

    <MultipleChoice>
    <Option isCorrect>inside `getStaticPaths`</Option>
    <Option>outside `getStaticPaths`</Option>
    </MultipleChoice>

2. The list of routes generated (returned) by `getStaticPaths()`

    <MultipleChoice>
    <Option isCorrect>inside `getStaticPaths`</Option>
    <Option>outside `getStaticPaths`</Option>
    </MultipleChoice>

3. Definitions of values to be used by each individual page in the component template.

    <MultipleChoice>
    <Option>inside `getStaticPaths`</Option>
    <Option isCorrect>outside `getStaticPaths`</Option>
    </MultipleChoice>

:::note[Takeaway]
To **give** information to a page route, write it **inside** `getStaticPaths()`.

To **use** information in the HTML template of a page route, write it **outside** `getStaticPaths()`.
:::

## Using props in dynamic routes

Now you can update your HTML template to include information from each blog post. 

1. To render a list of all posts on each of the dynamically-generated tag pages, add the following code to the template of `[tag].astro`:

    ```diff
    <!-- src/pages/posts/tags/[tag].astro -->

    <BaseLayout title={title}>   
      <p>Posts tagged with {title}</p>
    +  <ul>
    +    {posts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
    +  </ul>
    </BaseLayout>
    ```

2. You can even refactor this to use your `<BlogPost />` component instead! (Don't forget to import this component at the top of `[tag].astro`, along with your layout, so that you can use it.)

    ```diff
    <!-- src/pages/posts/tags/[tag].astro -->

    <BaseLayout title={title}>
      <p>Posts tagged with {title}</p>
      <ul>
    -   {posts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}        
    +   {posts.map(post => <BlogPost url={post.url} title={post.frontmatter.title}/>)}
      </ul>
    </BaseLayout>
    ```

3. Check your browser preview and you should now see a list of all your blog posts on every tag page. 

    But, that's not very helpful! you would like to display only the posts that contain that particular tag.


## Advanced: Showing only posts with matching tags

:::note
Even if it looks challenging, try following along with the steps to build this function yourself! But, if you don't feel up for a little JavaScript right now, you can skip ahead to the [finished version of the code](#final-code-sample) and add it directly to your project.
:::

Let's start by planning out the steps.

Replace your existing `getStaticPaths()` with the following **pseudocode** (a description in words of what you would _like_ your code to do, but not the actual code to execute) in your `getStaticPaths()` function:

```astro
---
// src/pages/posts/tags/[tag].astro

export async function getStaticPaths() {
  // 1. Retrieve data from all Markdown posts.
 
  // 2. Create a new `Set` for holding all the tags used on the blog.
  
  // 3. Loop through all the Markdown files, and add any tags found to the Set of tags.

  // 4. Turn your Set of tags into an array you can map through.

  // 5. For each tag, filter for the blog posts that include it, then return
  //    the name of the tag (for defining the parameters your page route)
  //    an array of posts that include the tag (to be passed as props).
}
---
```
We will tackle each piece individually. Some of the steps you have already seen

### Constructing `getStaticPaths()`

We have five tasks written in pseudocode to turn into code. Some will be shorter, and some will be longer.  Some of them you will be familiar with, but some of them might be new to you. That's OK! By the end, you'll have working code that you can inspect further if you need to.

Remember, each of these sections of code will be written _inside_ your `getStaticPaths()` function, in the order they appear.

### 1. Retrieve data from all Markdown posts

This should look familiar! You have written this line of code before:

```js
// src/pages/posts/tags/[tag].astro

  // 1. Retrieve data from all Markdown posts.
  const allPosts = await Astro.glob('../pages/posts/*.md');
```

### 2. Create a `Set` that will hold your tags

A `Set` is a JavaScript object that is a collection of unique items. It is similar to an array, but it igores repeats. Some of your blog posts may have the same tags (e.g. "learning in public"). But, you want to be able to list all the unique tags, only once each. 

```js
// src/pages/posts/tags/[tag].astro

  // 2. Create a new `Set` for holding all the tags used on the blog.
  const allTags = new Set();
```

### 3. Add each postâ€™s tags to your new `Set`

Because a `Set` ignores repeated values, you can add safely add every tag from every post to it. For each post, you will map through its collection of tags, and add every tag to your new tag set. Notice that you are mapping with in a map!

```js
// src/pages/posts/tags/[tag].astro

  // 3. Loop through all the Markdown files, and add any tags found to the Set of tags.
  allPosts.forEach((post) => {
    post.frontmatter.tags.forEach((tag) => allTags.add(tag));
  });
```

### 4. Convert your `Set` of unique tags into an array

Creating and adding to a `Set` ensures you don't have any duplicates, but an array is useful for mapping through and using those items.

```js
// src/pages/posts/tags/[tag].astro

  // 4. Turn your Set of tags into an array you can map through.
  let uniqueTags = Array.from(allTags);
```

### 5. Define the `return` value of the `getStaticPaths` function

What you want "returned" to us from any `getStaticPaths` function is an object containing `params` (what you should call each page route) and any `props` (data that you want passed into those pages), just like you had earlier in this lesson.

We still want each tag name to become a page on your website. But now, instead of listing out individually each page route's object to be returned, you want this list of objects to be generated automatically by mapping through all of your tags.

And, you want each of those page routes to "know about" only the blog posts that include that tag. So you also have to filter the posts before sending as props.

Complete the final section of pseudocode with the code below:

```js
// src/pages/posts/tags/[tag].astro

  // 5. For each tag, filter for the blog posts that include it, then return
  //    the name of the tag (for defining the parameters your page route)
  //    an array of posts that include the tag (to be passed as props).
  return uniqueTags.map((tag) => {
    const taggedPosts = allPosts.filter((post) => post.frontmatter.tags.includes(tag));
    return {
      params: { tag },
      props: { posts: taggedPosts },
    };
  });
```

## Final code sample

To check your work, or if you just want complete, correct code to copy into `[tag].astro`, here is what your Astro component should look like:

```astro
---
// src/pages/tags/[tag].astro

import BaseLayout from '../../layouts/BaseLayout.astro';
import BlogPost from '../../components/BlogPost.astro'

export async function getStaticPaths() {
  const allPosts = await Astro.glob('../posts/*.md');
  const allTags = new Set();
  
  allPosts.forEach((post) => {
    post.frontmatter.tags.forEach((tag) => allTags.add(tag));
  });
  
  const uniqueTags = Array.from(allTags);

  return uniqueTags.map((tag) => {
    const taggedPosts = allPosts.filter((post) => post.frontmatter.tags.includes(tag));
    return {
      params: { tag },
      props: { posts: taggedPosts },
    };
  });
}

const { posts } = Astro.props;
const { tag } = Astro.params;

let title = tag; 
---
<BaseLayout title={title}>
  <p>Posts tagged with {title}</p>
  <ul>
    {posts.map((post) => <BlogPost url={post.url} title={post.frontmatter.title}/>)}
  </ul>
</BaseLayout>
```

Now, you should be able to visit any of your tag pages in your browser preview! 

Navigate to `localhost:3000/tags/community` and you should see a list of only your blog posts with the tag `community`. Similarly `localhost:3000/tags/learn%20in%20public` should display a list of the blog posts tagged `learning in public`.

In the next section, you will use `Astro.glob()` again to build a page that will generate a list of every tag, with each tag each linking to its own page, automatically.

## Before you go

### Test your knowledge

Choose the term that matches the description.

1. A function you can write inside an Astro component script that returns an array of page routes that can receive props.

    <MultipleChoice>
      <Option>pseudocode</Option>
      <Option>dynamic routing</Option>
      <Option isCorrect>`getStaticPaths()`</Option>
      <Option>`Set`</Option>
    </MultipleChoice>

2. The process of creating multiple page routes from one function in Astro.

    <MultipleChoice>
      <Option>parameter</Option>
      <Option isCorrect>dynamic routing</Option>
      <Option>`getStaticPaths()`</Option>
      <Option>`Set`</Option>
    </MultipleChoice>

3. A JavaScript object that is a collection of unique, non-repeating items.

    <MultipleChoice>
      <Option>parameter</Option>
      <Option>pseudocode</Option>
      <Option>`getStaticPaths()`</Option>
      <Option isCorrect>`Set`</Option>
    </MultipleChoice>

4. A value that defines the name of a page route generated dynamically.

    <MultipleChoice>
      <Option isCorrect>parameter</Option>
      <Option>pseudocode</Option>
      <Option>dynamic routing</Option>
      <Option>`Set`</Option>
    </MultipleChoice>

5. An informal way of writing code, not meant to be executed by machines.

    <MultipleChoice>
      <Option>parameter</Option>
      <Option isCorrect>pseudocode</Option>
      <Option>dynamic routing</Option>
      <Option>`getStaticPaths()`</Option>
    </MultipleChoice>

### Checklist for moving on

<Checklist key="parameter">
- [ ] I generate pages dynamically, using one `[parameter].astro` file to generate several pages on my site.
- [ ] I can pass `props` to each page route, and use these props in the common page template.
- [ ] I can plan my steps in pseudocode, creating a roadmap for future work.
</Checklist>

### Resources

- [Dynamic Page Routing in Astro](/en/core-concepts/routing/#dynamic-routes)

- [`getStaticPaths()` API documentation](/en/reference/api-reference/#getstaticpaths)
